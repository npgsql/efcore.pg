# Range Type Mapping

PostgreSQL has the unique feature of supporting [*range data types*](https://www.postgresql.org/docs/current/static/rangetypes.html). Ranges represent a range of numbers, dates or other data types, and allow you to easily query ranges which contain a value, perform set operations (e.g. query ranges which contain other ranges), and other similar operations. The range operations supported by PostgreSQL are listed [in this page](https://www.postgresql.org/docs/current/static/functions-range.html). The Npgsql EF Core provider allows you to seemlessly map PostgreSQL ranges, and even perform operations on them that get translated to SQL for server evaluation.

# Mapping ranges

Npgsql maps PostgreSQL ranges to the generic CLR type `NpgqslRange<T>`:

```c#
public class Event
{
    public int Id { get; set; }
    public string Name { get; set; }
    public NpgsqlRange<DateTime> Duration { get; set; }
}
```

This will create a column of type `daterange` in your database. You can similarly have properties of type `NpgsqlRange<int>`, `NpgsqlRange<long>`, etc.

# User-defined ranges

> [!NOTE]
> This feature was introduced in version 2.2

PostgreSQL comes with 6 built-in ranges: `int4range`, `int8range`, `numrange`, `tsrange`, `tstzrange`, `daterange`; these can be used simply by adding the appropriate `NpgsqlRange<T>` property in your entities as shown above. You can also define your own range types over arbitrary types, and use those in EF Core as well.

To make the EF Core type mapper aware of your user-defined range, call the `MapRange()` method in your context's `OnConfiguring()` method as follows:
```c#
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    => optionsBuilder.UseNpgsql(
        "<connection_string>",
        options => options.MapRange<float>("floatrange"));
```

This allows you to have properties of type `NpgsqlRange<float>`, which will be mapped to PostgreSQL `floatrange`.

The above does *not* create the `floatrange` type for you. In order to do that, include the following in your context's `OnModelCreating()`:

```c#
protected override void OnModelCreating(ModelBuilder modelBuilder)
    => modelBuilder.ForNpgsqlHasRange("floatrange", "real");
```

This will cause the appropriate [`CREATE TYPE ... AS RANGE`](https://www.postgresql.org/docs/current/static/sql-createtype.html) statement to be generated in your migrations, ensuring that your range is created and ready for use. Note that `ForNpgsqlHasRange()` supports additional parameters as supported by PostgreSQL `CREATE TYPE`.

# Operation translation

Ranges can be queried via extensions methods on `NpgsqlRange`:

```c#
var events = context.Events.Where(p => p.Duration.Contains(someDate));
```

This will translate to an SQL operation using the PostgreSQL `@>` operator, evaluating at the server and saving you from transfering the entire `Events` table to the client. Note that you can (and probably should) create indexes to make this operation more efficient, see the PostgreSQL docs for more info.

The following table lists the range operations that currently get translated. If you run into a missing operation, please open an issue.

| C# expression                                              | SQL generated by Npgsql |
|------------------------------------------------------------|-------------------------|
| `.Where(c => c.SomeRange.Contains(3))`                     | [`WHERE x."SomeRange" @> 3`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.Contains(otherRange))`            | [`WHERE x."SomeRange" @> @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.ContainedBy(otherRange))`         | [`WHERE x."SomeRange" <@ @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange == otherRange)`                   | [`WHERE x."SomeRange" = @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange != otherRange)`                   | [`WHERE x."SomeRange" <> @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.Overlaps(otherRange))`            | [`WHERE x."SomeRange" && @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.IsStrictlyLeftOf(otherRange))`    | [`WHERE x."SomeRange" << @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.IsStrictlyRightOf(otherRange))`   | [`WHERE x."SomeRange" >> @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.DoesNotExtendLeftOf(otherRange))` | [`WHERE x."SomeRange" &> @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.DoesNotExtendRightOf(otherRange))`| [`WHERE x."SomeRange" <& @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Where(c => c.SomeRange.IsAdjacentTo(otherRange))`        | [`WHERE x."SomeRange" -\|- @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Select(c => c.SomeRange.Union(otherRange))`               | [`SELECT x."SomeRange" + @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Select(c => c.SomeRange.Intersect(otherRange))`           | [`SELECT x."SomeRange" * @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)
| `.Select(c => c.SomeRange.Except(otherRange))`              | [`SELECT x."SomeRange" - @__otherRange_0`](https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE)

