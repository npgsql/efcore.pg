













// <auto-generated />

using System;
using System.Reflection;
using System.Resources;
using JetBrains.Annotations;

using Microsoft.EntityFrameworkCore.Diagnostics;
using Npgsql.EntityFrameworkCore.PostgreSQL.Diagnostics;
using Microsoft.Extensions.Logging;


namespace Npgsql.EntityFrameworkCore.PostgreSQL.Internal
{
    /// <summary>
    ///		This API supports the Entity Framework Core infrastructure and is not intended to be used
    ///     directly from your code. This API may change or be removed in future releases.
    /// </summary>
    public static class NpgsqlStrings
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Npgsql.EntityFrameworkCore.PostgreSQL.Properties.NpgsqlStrings", typeof(NpgsqlStrings).GetTypeInfo().Assembly);


        /// <summary>

        ///     PostgreSQL sequences cannot be used to generate values for the property '{property}' on entity type '{entityType}' because the property type is '{propertyType}'. Sequences can only be used with integer properties.

        /// </summary>

        public static string SequenceBadType([CanBeNull] object property, [CanBeNull] object entityType, [CanBeNull] object propertyType)
            => string.Format(
                GetString("SequenceBadType", nameof(property), nameof(entityType), nameof(propertyType)),
                property, entityType, propertyType);


        /// <summary>

        ///     An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding 'EnableRetryOnFailure()' to the 'UseSqlServer' call.

        /// </summary>

        public static string TransientExceptionDetected
            => GetString("TransientExceptionDetected");


        /// <summary>

        ///     The property '{property}' on entity type '{entityType}' is configured to use 'SequenceHiLo' value generator, which is only intended for keys. If this was intentional configure an alternate key on the property, otherwise call 'ValueGeneratedNever' or configure store generation for this property.

        /// </summary>

        public static string NonKeyValueGeneration([CanBeNull] object property, [CanBeNull] object entityType)
            => string.Format(
                GetString("NonKeyValueGeneration", nameof(property), nameof(entityType)),
                property, entityType);


        /// <summary>

        ///     Found column with table: {tableName}, column name: {columnName}, data type: {dataType}, nullable: {isNullable}, default value: {defaultValue}

        /// </summary>

        public static readonly EventDefinition<string, string, string, bool, string> LogFoundColumn
            = new EventDefinition<string, string, string, bool, string>(
                NpgsqlEventId.ColumnFound,
                LogLevel.Debug,
                LoggerMessage.Define<string, string, string, bool, string>(
                    LogLevel.Debug,
                    NpgsqlEventId.ColumnFound,
                    _resourceManager.GetString("LogFoundColumn")));


        /// <summary>

        ///     Found foreign key on table: {tableName}, name: {foreignKeyName}, principal table: {principalTableName}, delete action: {deleteAction}.

        /// </summary>

        public static readonly EventDefinition<string, string, string, string> LogFoundForeignKey
            = new EventDefinition<string, string, string, string>(
                NpgsqlEventId.ForeignKeyFound,
                LogLevel.Debug,
                LoggerMessage.Define<string, string, string, string>(
                    LogLevel.Debug,
                    NpgsqlEventId.ForeignKeyFound,
                    _resourceManager.GetString("LogFoundForeignKey")));


        /// <summary>

        ///     For foreign key {fkName} on table {tableName}, unable to model the end of the foreign key on principal table {principaltableName}. This is usually because the principal table was not included in the selection set.

        /// </summary>

        public static readonly EventDefinition<string, string, string> LogPrincipalTableNotInSelectionSet
            = new EventDefinition<string, string, string>(
                NpgsqlEventId.ForeignKeyReferencesMissingPrincipalTableWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string, string, string>(
                    LogLevel.Warning,
                    NpgsqlEventId.ForeignKeyReferencesMissingPrincipalTableWarning,
                    _resourceManager.GetString("LogPrincipalTableNotInSelectionSet")));


        /// <summary>

        ///     Unable to find a schema in the database matching the selected schema {schema}.

        /// </summary>

        public static readonly EventDefinition<string> LogMissingSchema
            = new EventDefinition<string>(
                NpgsqlEventId.MissingSchemaWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string>(
                    LogLevel.Warning,
                    NpgsqlEventId.MissingSchemaWarning,
                    _resourceManager.GetString("LogMissingSchema")));


        /// <summary>

        ///     Unable to find a table in the database matching the selected table {table}.

        /// </summary>

        public static readonly EventDefinition<string> LogMissingTable
            = new EventDefinition<string>(
                NpgsqlEventId.MissingTableWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string>(
                    LogLevel.Warning,
                    NpgsqlEventId.MissingTableWarning,
                    _resourceManager.GetString("LogMissingTable")));


        /// <summary>

        ///     Found sequence name: {name}, data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.

        /// </summary>

        public static readonly FallbackEventDefinition LogFoundSequence
            = new FallbackEventDefinition(
                NpgsqlEventId.SequenceFound,
                LogLevel.Debug,
                _resourceManager.GetString("LogFoundSequence"));


        /// <summary>

        ///     Found table with name: {name}.

        /// </summary>

        public static readonly EventDefinition<string> LogFoundTable
            = new EventDefinition<string>(
                NpgsqlEventId.TableFound,
                LogLevel.Debug,
                LoggerMessage.Define<string>(
                    LogLevel.Debug,
                    NpgsqlEventId.TableFound,
                    _resourceManager.GetString("LogFoundTable")));


        /// <summary>

        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different value generation strategies.

        /// </summary>

        public static string DuplicateColumnNameValueGenerationStrategyMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table)
            => string.Format(
                GetString("DuplicateColumnNameValueGenerationStrategyMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);


        /// <summary>

        ///     Found index with name: {indexName}, table: {tableName}, is unique: {isUnique}.

        /// </summary>

        public static readonly EventDefinition<string, string, bool> LogFoundIndex
            = new EventDefinition<string, string, bool>(
                NpgsqlEventId.IndexFound,
                LogLevel.Debug,
                LoggerMessage.Define<string, string, bool>(
                    LogLevel.Debug,
                    NpgsqlEventId.IndexFound,
                    _resourceManager.GetString("LogFoundIndex")));


        /// <summary>

        ///     Found primary key with name: {primaryKeyName}, table: {tableName}.

        /// </summary>

        public static readonly EventDefinition<string, string> LogFoundPrimaryKey
            = new EventDefinition<string, string>(
                NpgsqlEventId.PrimaryKeyFound,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    NpgsqlEventId.PrimaryKeyFound,
                    _resourceManager.GetString("LogFoundPrimaryKey")));


        /// <summary>

        ///     Found unique constraint with name: {uniqueConstraintName}, table: {tableName}.

        /// </summary>

        public static readonly EventDefinition<string, string> LogFoundUniqueConstraint
            = new EventDefinition<string, string>(
                NpgsqlEventId.UniqueConstraintFound,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    NpgsqlEventId.UniqueConstraintFound,
                    _resourceManager.GetString("LogFoundUniqueConstraint")));


        /// <summary>

        ///     For foreign key {foreignKeyName} on table {tableName}, unable to find the column called {principalColumnName} on the foreign key's principal table, {principaltableName}. Skipping foreign key.

        /// </summary>

        public static readonly EventDefinition<string, string, string, string> LogPrincipalColumnNotFound
            = new EventDefinition<string, string, string, string>(
                NpgsqlEventId.ForeignKeyPrincipalColumnMissingWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string, string, string, string>(
                    LogLevel.Warning,
                    NpgsqlEventId.ForeignKeyPrincipalColumnMissingWarning,
                    _resourceManager.GetString("LogPrincipalColumnNotFound")));


        /// <summary>

        ///     The specified table '{table}' is not valid. Specify tables using the format '[schema].[table]'.

        /// </summary>

        public static string InvalidTableToIncludeInScaffolding([CanBeNull] object table)
            => string.Format(
                GetString("InvalidTableToIncludeInScaffolding", nameof(table)),
                table);


        /// <summary>

        ///     The 'FreeText' method is not supported because the query has switched to client-evaluation. Inspect the log to determine which query expressions are triggering client-evaluation.

        /// </summary>

        public static string FreeTextFunctionOnClient
            => GetString("FreeTextFunctionOnClient");


        /// <summary>

        ///     Enum column '{name}' cannot be scaffolded, define a CLR enum type and add the property manually.

        /// </summary>

        public static readonly EventDefinition<string> LogEnumColumnSkipped
            = new EventDefinition<string>(
                NpgsqlEventId.EnumColumnSkippedWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string>(
                    LogLevel.Warning,
                    NpgsqlEventId.EnumColumnSkippedWarning,
                    _resourceManager.GetString("LogEnumColumnSkipped")));


        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name);
            for (var i = 0; i < formatterNames.Length; i++)
            {
                value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
            }

            return value;
        }
    }
}
